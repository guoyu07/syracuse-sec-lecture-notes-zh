# 三、Set-UID 特权程序

> 原文：[Set-UID Programs and Vulnerabilities](http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Set_UID.pdf)

> 译者：[飞龙](https://github.com/wizardforcel)

这个讲义的主要目标就是来讨论特权程序，为什么需要他们，他们如何工作，以及它们有什么安全问题。特权程序是可以给予用户额外权限的程序，这些权限超出了用户已有的权限。例如，Web 服务器是特权程序，因为他允许远程用户访问服务端的资源；Set-UID 程序也是个特权程序，因为他允许用户在程序执行期间获得 ROOT 权限。

这篇讲义中，我们会专注于 Set-UID 的机制，并且在我们的案例学习中使用它。但是，我们在这里讨论的许多安全原则也可以用在其他特权程序上。

## 1 Set-UID 机制如何工作

+   动机
    +   你想让其他人能够搜索文件中的一些单词，但是不想让他们能够读取文件。如何实现它呢？
    +   用户的密码储存在`/etc/shadow`中，普通用户不可读写。但是，`passwd`程序允许用户修改它们自己的密码。也就是，当用户执行`passwd`，它们可以突然修改`/etc/shadow`，并且用户只能修改`/etc/shadow`中的一项，但不是其他人的条目。如何实现？
+   Set-UID 程序
    +   有效 UID 和真实 UID 的概念
    +   对于非 Set-UID 程序，二者相同
    +   对于 Set-UID 程序，前者是程序所有者的 UID，后者是程序用户的 UID。
+   有效 UID 和真实 UID
    +   登录时期，真实 UID 和有效 UID，以及登录过程保存的 UID 都设为负责进程创建的用户的登录 UID。对于真实、有效和保存的组 ID 也一样。它们设为负责进程创建的用户的组 ID。
    +   当进程调用`exec`系列函数之一，来执行文件（程序）时，进程相关的用户和组标识符会发生改变。如果执行的文件是个 Set-UID 文件，进程的有效和保存的 UID 会设为所执行文件的所有者。如果所执行文件是个 Set-GID 文件，有效 UID、保存的 UID 以及有效 GID、保存的 GID 不会改变。
    +   访问控制基于有效 UID 和 GID。
+   为什么`passwd`、`chsh`和`su`程序需要为 Set-UID 程序？
+   Windows NT/2000 中有没有 Set-UID 程序？如果没有，相同问题在 Windows 中如何解决？
    +   Windows 没有 Set-UID 这个概念。不同的机制用于实现权限功能。开发者会将特权程序编写为服务，用户使用本地过程调用将命令行参数发给服务。
    +   服务可以自动或手动启动。
    +   每个服务都有安全描述符，制定了哪个用户允许启动、停止和配置该服务。
    +   服务通常在本地系统账户下运行。
+   如何打开 Set-UID 位：

    ```
    % chmod 4755 file ---> -rwsr-xr-x 
    ```
    
+   Set-UID 在 Minix 中如何实现？

    ```
    /* This is the per-process information */ 
    EXTERN struct fproc {
        uid_t fp_realuid; /* real user id */ 
        uid_t fp_effuid; /* effective user id */ 
        gid_t fp_realgid; /* real group id */ 
        gid_t fp_effgid; /* effective group id */ 
        ...
    }
    ```

+   Set-UID 机制的恶意使用：
    +   攻击者可以使用你的账户十秒。它能够植入后门，以便之后再回到你的账户吗？
    
    ```
    % cp /bin/sh /tmp 
    % chmod 4777 /tmp/sh
    ```
    
    由此，攻击者创建了 Set-UID SHell 程序，你是这个程序的所有者。因此，当攻击者之后再运行 Shell 时，它使用你的权限运行。
+   问题：
    +   普通用户是否可以调试 Set-Root-UID 程序？
    +   普通用户是否可以使用`chown`来将文件所有者修改为任何用户？
    
## 2 Set-UID 程序的漏洞

### 2.1 隐藏的输入：环境变量

特权程序必须对所有输入进行安全检查。输入检查实际上是访问控制的一部分，特权程序必须这么做，来确保程序的安全。很多安全问题都是输入检查的错误造成的。

如果输入在程序中显式存在，程序员可能记得执行输入检查；如果输入隐式存在，输入检查可能会忘记，因为程序员可能不知道这个输入的存在。环境变量就是这类输入。

每个 Unix 进程都在特定环境下运行。环境由环境变量表组成，每个变量都有赋值。一些程序内部使用这些环境变量，Shell 程序就是这些程序的例子。换句话说，一些环境变量的值可以 Shell 程序的行为。

由于环境变量由用户控制，如果程序依赖这些变量，用户可以间接影响这类程序的行为，通过修改一些环境变量的值。因此，理解特权程序是否依赖任何环境变量的值就十分重要。一种程序可能被环境变量影响的方式，就是在程序中显式使用环境变量的值。在 C 语言中，程序可以使用`getenv`来访问环境变量的值。但是，也有许多例子，程序隐式使用环境变量。这就是我们在许多 Set-UID 程序中看到的漏洞。我们会在这一节中展示几个例子。

+   `PATH`环境变量
    +   在 Shell 中执行命令式，Shell 会使用`PATH`环境变量搜索所有命令，它包含一个目录列表。Shell 程序通过目录列表（和他们在`PATH`环境变量的相同顺序）来搜索。第一个匹配命令名称的程序会被执行。
    +   下面会发生什么？要注意`system (const char *cmd)`库函数首先调用`/bin/sh`程序，之后让 SHell 程序执行`cmd`。
    
    ```
    system ("mail");
    ```
    
+   攻击者可以将`PATH`修改成这个，并使当前目录下的`mail`被执行。

    ```
    PATH=".:$PATH"; export PATH
    ```
    
    拿超人来比喻的话，如果超人的指令是“左转”（坏人在左边而好人在右边，你可以假设他要攻击坏人）。如果攻击者准确知道左转指令什么时候以及在哪里执行，他就可以做出与上面类似的攻击。因为“左边”是个相对的方向，并不是绝对方向。如果攻击者事先在你想要左转的地方，放置一个旋转设备，并将你旋转 180 度，只要你踏上了它，“左转”就变成了转到好人那里。如果你遵循了指令，你最后就会攻击好人。
+   `IFS`环境变量
    +   `IFS`变量决定了哪些字符被解释为空白字符。它代表了内部字段分隔符。假设我们设置它来包含斜杠字符：
    
    ```
    IFS="/ \t\n"; export IFS 
    PATH=".:$PATH"; export PATH
    ```
